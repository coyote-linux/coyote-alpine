#!/usr/bin/env php
<?php
/**
 * apply-config - Apply system configuration
 *
 * This script reads the configuration and applies it to the system,
 * including network interface configuration, DNS, hostname, and timezone.
 *
 * Environment variables:
 *   COYOTE_CONFIG_FILE - Path to config file to apply (for web admin apply)
 *
 * Normal boot sequence (no COYOTE_CONFIG_FILE):
 *   1. Mount config partition if not mounted
 *   2. Load from /mnt/config/system.json
 *   3. Apply to system
 *   4. Write copy to /tmp/running-config/system.json
 */

require_once '/opt/coyote/lib/autoload.php';

use Coyote\Config\ConfigLoader;

/**
 * Apply system configuration
 */
function applyConfig(): bool
{
    $loader = new ConfigLoader();
    $errors = [];

    // Check for explicit config file from environment (web admin apply)
    $configFileEnv = getenv('COYOTE_CONFIG_FILE');

    if ($configFileEnv && file_exists($configFileEnv)) {
        // Web admin is applying working-config
        echo "  Using config file: {$configFileEnv}\n";
        try {
            $config = $loader->load($configFileEnv);
        } catch (\Exception $e) {
            echo "Error loading configuration: " . $e->getMessage() . "\n";
            return false;
        }
    } else {
        // Normal boot - mount config partition and load from persistent storage
        $configPath = '/mnt/config';
        $configFile = $configPath . '/system.json';

        echo "  Config path: {$configPath}\n";
        echo "  Config file: {$configFile}\n";

        // Check if config partition is mounted
        $mounts = file_get_contents('/proc/mounts');
        if (strpos($mounts, '/mnt/config') !== false) {
            echo "  Config partition: mounted\n";
        } else {
            echo "  Config partition: NOT MOUNTED\n";
            echo "  Attempting to find and mount config partition...\n";

            // Find candidate partitions (second partition on each disk)
            $candidates = array_merge(
                glob('/dev/sd?2') ?: [],
                glob('/dev/nvme?n?p2') ?: [],
                glob('/dev/vd?2') ?: []
            );

            echo "  Candidate partitions: " . (empty($candidates) ? 'none found' : implode(', ', $candidates)) . "\n";

            // Try to mount config partition
            $mounted = false;
            foreach ($candidates as $part) {
                if (!file_exists($part)) continue;

                echo "  Trying: {$part}...\n";

                // Try mounting (busybox mount requires -t type)
                $mountOutput = [];
                exec("mount -t ext4 -o ro " . escapeshellarg($part) . " " . escapeshellarg($configPath) . " 2>&1", $mountOutput, $ret);
                if ($ret === 0) {
                    if (file_exists($configFile)) {
                        echo "  Found config on: {$part}\n";
                        $mounted = true;
                        break;
                    }
                    echo "  Mounted {$part} but no system.json found\n";
                    exec("umount " . escapeshellarg($configPath) . " 2>&1");
                } else {
                    echo "  Mount failed: " . implode(' ', $mountOutput) . "\n";
                }
            }

            if (!$mounted) {
                echo "  WARNING: Could not find or mount config partition\n";
            }
        }

        if (file_exists($configFile)) {
            echo "  Config file: exists\n";
            try {
                $config = $loader->load($configFile);
            } catch (\Exception $e) {
                echo "Error loading configuration: " . $e->getMessage() . "\n";
                return false;
            }
        } else {
            echo "  Config file: NOT FOUND (using defaults)\n";
            $config = getDefaults();
        }
    }

    // Debug: Show loaded config summary
    $ifaceCount = count($config['network']['interfaces'] ?? []);
    $rawDnsConfig = $config['system']['nameservers'] ?? ($config['network']['dns'] ?? []);
    if (!is_array($rawDnsConfig)) {
        $rawDnsConfig = [$rawDnsConfig];
    }
    $dnsCount = count($rawDnsConfig);
    echo "  Loaded: {$ifaceCount} interface(s), {$dnsCount} DNS server(s)\n";

    // Apply hostname
    $hostname = $config['system']['hostname'] ?? 'coyote';
    $domain = $config['system']['domain'] ?? '';

    file_put_contents('/etc/hostname', $hostname . "\n");
    exec("hostname " . escapeshellarg($hostname));
    echo "  Hostname: {$hostname}\n";

    // Build /etc/hosts
    $fqdn = $domain ? "{$hostname}.{$domain}" : $hostname;
    $hosts = "127.0.0.1\tlocalhost\n";
    $hosts .= "127.0.1.1\t{$fqdn} {$hostname}\n";
    $hosts .= "::1\t\tlocalhost ip6-localhost ip6-loopback\n";
    file_put_contents('/etc/hosts', $hosts);

    // Apply timezone
    $tz = $config['system']['timezone'] ?? 'UTC';
    $tzFile = "/usr/share/zoneinfo/{$tz}";
    if (file_exists($tzFile)) {
        @unlink('/etc/localtime');
        @symlink($tzFile, '/etc/localtime');
        echo "  Timezone: {$tz}\n";
    }

    // Configure DNS (resolv.conf)
    // Prefer system.nameservers (web admin system page), fall back to network.dns (legacy/TUI)
    $dns = $config['system']['nameservers'] ?? ($config['network']['dns'] ?? []);
    $search = $config['network']['search'] ?? [];

    // Ensure dns is a flat array of strings
    if (!is_array($dns)) {
        $dns = [$dns];
    }
    // Flatten in case of nested array
    $dnsServers = [];
    foreach ($dns as $ns) {
        if (is_array($ns)) {
            foreach ($ns as $server) {
                if (is_string($server) && !empty($server)) {
                    $dnsServers[] = $server;
                }
            }
        } elseif (is_string($ns) && !empty($ns)) {
            $dnsServers[] = $ns;
        }
    }

    // Ensure search is a flat array of strings
    if (!is_array($search)) {
        $search = !empty($search) ? [$search] : [];
    }
    $searchDomains = [];
    foreach ($search as $domain) {
        if (is_string($domain) && !empty($domain)) {
            $searchDomains[] = $domain;
        }
    }

    $resolv = "";
    if (!empty($searchDomains)) {
        $resolv .= "search " . implode(' ', $searchDomains) . "\n";
    }
    foreach ($dnsServers as $ns) {
        $resolv .= "nameserver {$ns}\n";
    }

    $hasStaticDns = !empty($dnsServers);

    if (!empty($resolv)) {
        file_put_contents('/etc/resolv.conf', $resolv);
        echo "  DNS configured\n";
    }

    // Configure loopback interface
    echo "  Interface lo:\n";
    exec("ip addr add 127.0.0.1/8 dev lo 2>&1", $output, $ret);
    exec("ip link set lo up 2>&1", $output, $ret);
    if ($ret === 0) {
        echo "    Address: 127.0.0.1/8\n";
    } else {
        $errors[] = "Failed to configure loopback interface";
    }

    // Configure network interfaces
    $interfaces = $config['network']['interfaces'] ?? [];

    foreach ($interfaces as $ifaceConfig) {
        $name = $ifaceConfig['name'] ?? null;
        $type = $ifaceConfig['type'] ?? 'static';
        $enabled = $ifaceConfig['enabled'] ?? true;

        // Support both 'addresses' (array) and 'address' (string) formats
        $addresses = $ifaceConfig['addresses'] ?? [];
        if (empty($addresses) && !empty($ifaceConfig['address'])) {
            $addresses = [$ifaceConfig['address']];
        }

        if (!$name) {
            continue;
        }

        echo "  Interface {$name}:\n";

        // Check if interface exists
        if (!file_exists("/sys/class/net/{$name}")) {
            echo "    WARNING: Interface {$name} not found\n";
            $errors[] = "Interface {$name} not found";
            continue;
        }

        // Handle disabled interfaces
        if ($type === 'disabled' || !$enabled) {
            exec("ip addr flush dev " . escapeshellarg($name) . " 2>&1");
            exec("ip link set " . escapeshellarg($name) . " down 2>&1");
            echo "    Status: disabled\n";
            continue;
        }

        // Flush existing addresses
        exec("ip addr flush dev " . escapeshellarg($name) . " 2>&1");

        // Bring interface up
        $cmdOutput = [];
        exec("ip link set " . escapeshellarg($name) . " up 2>&1", $cmdOutput, $ret);
        if ($ret !== 0) {
            $errors[] = "Failed to bring up interface {$name}: " . implode(' ', $cmdOutput);
            continue;
        }
        echo "    Status: up\n";

        // Handle by type
        if ($type === 'static') {
            // Set IP addresses (CIDR notation expected, e.g., 192.168.0.1/24)
            foreach ($addresses as $address) {
                if (empty($address)) continue;
                $cmdOutput = [];
                exec("ip addr add " . escapeshellarg($address) . " dev " . escapeshellarg($name) . " 2>&1", $cmdOutput, $ret);
                if ($ret === 0) {
                    echo "    Address: {$address}\n";
                } else {
                    $errors[] = "Failed to set address {$address} on {$name}: " . implode(' ', $cmdOutput);
                }
            }
        } elseif ($type === 'dhcp') {
            // Start DHCP client (using dhcpcd)
            $hostname = $ifaceConfig['dhcp_hostname'] ?? '';

            // Stop any existing dhcpcd for this interface
            exec("dhcpcd -x " . escapeshellarg($name) . " 2>&1");
            usleep(100000); // 100ms

            // Build dhcpcd command
            // -b = background immediately
            // -h = hostname to send
            // -t 0 = wait forever (no timeout)
            $cmd = "dhcpcd -b -t 0";
            if ($hasStaticDns) {
                // Keep static resolver settings from configuration when explicitly set
                $cmd .= " -C domain_name_servers -C domain_search -C domain_name";
            }
            if (!empty($hostname)) {
                $cmd .= " -h " . escapeshellarg($hostname);
            }
            $cmd .= " " . escapeshellarg($name);

            echo "    DHCP: starting ({$cmd})\n";
            $cmdOutput = [];
            exec($cmd . " 2>&1", $cmdOutput, $ret);
            if ($ret === 0) {
                echo "    DHCP: started\n";
            } else {
                $errorMsg = implode(' ', $cmdOutput);
                $errors[] = "Failed to start DHCP on {$name}: {$errorMsg}";
                echo "    DHCP: FAILED - {$errorMsg}\n";
            }
        }
    }

    // Configure routes
    $routes = $config['network']['routes'] ?? [];
    foreach ($routes as $route) {
        $dest = $route['destination'] ?? null;
        $gateway = $route['gateway'] ?? null;
        $dev = $route['interface'] ?? $route['device'] ?? null;

        if (!$dest) continue;

        if ($dest === 'default') {
            // Remove existing default route first
            exec("ip route del default 2>&1");
            $cmd = "ip route add default";
        } else {
            $cmd = "ip route replace " . escapeshellarg($dest);
        }

        if ($gateway) {
            $cmd .= " via " . escapeshellarg($gateway);
        }
        if ($dev) {
            $cmd .= " dev " . escapeshellarg($dev);
        }

        exec($cmd . " 2>&1", $output, $ret);
        if ($ret === 0) {
            echo "  Route: {$dest}" . ($gateway ? " via {$gateway}" : "") . ($dev ? " dev {$dev}" : "") . "\n";
        } else {
            $errors[] = "Failed to add route to {$dest}";
        }
    }

    applyDhcpService($config, $errors);
    applyNtpService($config, $errors);

    // Enable IP forwarding (always enable for a firewall/router)
    exec('sysctl -w net.ipv4.ip_forward=1 2>&1');
    exec('sysctl -w net.ipv6.conf.all.forwarding=1 2>&1');

    // If this is a boot-time apply (not from web admin), always refresh running-config
    // so dependent services (firewall/dropbear/webadmin ACLs) use the latest persisted config
    // even when non-fatal service apply steps reported errors.
    if (!$configFileEnv) {
        writeRunningConfig($config);
    }

    // Report results
    if (!empty($errors)) {
        echo "\nConfiguration applied with errors:\n";
        foreach ($errors as $error) {
            echo "  - {$error}\n";
        }
        return false;
    }

    echo "\nConfiguration applied successfully.\n";
    return true;
}

/**
 * Write configuration to running-config.
 *
 * @param array $config The configuration data
 */
function writeRunningConfig(array $config): void
{
    $runningConfigDir = '/tmp/running-config';
    $runningConfigFile = $runningConfigDir . '/system.json';

    if (!is_dir($runningConfigDir)) {
        mkdir($runningConfigDir, 0755, true);
    }

    $json = json_encode($config, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    file_put_contents($runningConfigFile, $json);

    // Set ownership for web admin access
    @chown($runningConfigFile, 'lighttpd');
    @chgrp($runningConfigFile, 'lighttpd');

    echo "  Running config updated: {$runningConfigFile}\n";
}

function runRcService(string $service, string $action, array &$output, &$ret): void
{
    $ret = 1;
    $baseCmd = 'rc-service ' . escapeshellarg($service) . ' ' . escapeshellarg($action);

    $timeoutBinary = null;
    foreach (['/usr/bin/timeout', '/bin/timeout'] as $candidate) {
        if (is_executable($candidate)) {
            $timeoutBinary = $candidate;
            break;
        }
    }

    if ($timeoutBinary !== null) {
        $cmd = $timeoutBinary . ' 20 ' . $baseCmd . ' 2>&1';
    } else {
        $cmd = $baseCmd . ' 2>&1';
    }

    exec($cmd, $output, $ret);
}

function deferServiceAction(string $actionScript, array &$errors, string $errorLabel): bool
{
    $cmd = "sh -c '(sleep 2; {$actionScript}) >/dev/null 2>&1 &'";
    exec($cmd, $output, $ret);
    if ($ret !== 0) {
        $errors[] = 'Failed to schedule ' . $errorLabel;
        return false;
    }

    return true;
}

function applyDhcpService(array $config, array &$errors): void
{
    $dhcpConfig = $config['services']['dhcpd'] ?? [];
    $enabled = (bool)($dhcpConfig['enabled'] ?? false);
    $dnsForwarderEnabled = (bool)($config['services']['dns']['enabled'] ?? false);
    $dhcpConfigFile = '/etc/dnsmasq.d/dhcp.conf';

    if (!is_dir('/etc/dnsmasq.d')) {
        @mkdir('/etc/dnsmasq.d', 0755, true);
    }

    $deferServiceControl = (getenv('RC_SVCNAME') === 'coyote-config');

    if (!$enabled) {
        file_put_contents($dhcpConfigFile, '');

        if ($dnsForwarderEnabled) {
            if ($deferServiceControl) {
                if (deferServiceAction('rc-service dnsmasq reload || rc-service dnsmasq start', $errors, 'dnsmasq service update')) {
                    echo "  DHCP server: disabled (dnsmasq reload deferred)\n";
                }
                return;
            }

            $output = [];
            runRcService('dnsmasq', 'reload', $output, $ret);
            if ($ret !== 0) {
                $output = [];
                runRcService('dnsmasq', 'start', $output, $ret);
            }

            if ($ret !== 0) {
                $errors[] = 'Failed to reload or start dnsmasq while DHCP is disabled: ' . implode(' ', $output);
            }
        } else {
            if ($deferServiceControl) {
                if (deferServiceAction('rc-service dnsmasq stop', $errors, 'dnsmasq service update')) {
                    echo "  DHCP server: disabled (dnsmasq stop deferred)\n";
                }
                return;
            }

            $output = [];
            runRcService('dnsmasq', 'stop', $output, $ret);
            if ($ret !== 0) {
                $combined = implode(' ', $output);
                if (stripos($combined, 'stopped') === false && stripos($combined, 'not running') === false) {
                    $errors[] = 'Failed to stop dnsmasq while DHCP is disabled: ' . $combined;
                }
            }
        }

        echo "  DHCP server: disabled\n";
        return;
    }

    $interface = trim((string)($dhcpConfig['interface'] ?? ''));
    $rangeStart = trim((string)($dhcpConfig['range_start'] ?? ''));
    $rangeEnd = trim((string)($dhcpConfig['range_end'] ?? ''));
    $subnetMask = trim((string)($dhcpConfig['subnet_mask'] ?? ''));
    $gateway = trim((string)($dhcpConfig['gateway'] ?? ''));
    $domain = trim((string)($dhcpConfig['domain'] ?? ''));
    $dnsServers = $dhcpConfig['dns_servers'] ?? [];
    $leaseTime = (int)($dhcpConfig['lease_time'] ?? 86400);
    $reservations = $dhcpConfig['reservations'] ?? [];

    if ($interface === '' || $rangeStart === '' || $rangeEnd === '') {
        $errors[] = 'DHCP configuration incomplete (interface/range_start/range_end required)';
        return;
    }

    if (!file_exists('/sys/class/net/' . $interface)) {
        $errors[] = "DHCP interface not found: {$interface}";
        return;
    }

    if (!is_array($dnsServers)) {
        $dnsServers = array_values(array_filter([
            is_string($dnsServers) ? trim($dnsServers) : '',
        ]));
    }

    $confLines = [];
    $confLines[] = "interface={$interface}";
    if ($subnetMask !== '') {
        $confLines[] = "dhcp-range={$rangeStart},{$rangeEnd},{$subnetMask},{$leaseTime}s";
    } else {
        $confLines[] = "dhcp-range={$rangeStart},{$rangeEnd},{$leaseTime}s";
    }

    if ($gateway !== '') {
        $confLines[] = "dhcp-option=option:router,{$gateway}";
    }

    if (!empty($dnsServers)) {
        $confLines[] = 'dhcp-option=option:dns-server,' . implode(',', $dnsServers);
    }

    if ($domain !== '') {
        $confLines[] = "domain={$domain}";
    }

    foreach ($reservations as $reservation) {
        $mac = trim((string)($reservation['mac'] ?? ''));
        $ip = trim((string)($reservation['ip'] ?? ''));
        $hostname = trim((string)($reservation['hostname'] ?? ''));

        if ($mac === '' || $ip === '') {
            continue;
        }

        if ($hostname !== '') {
            $confLines[] = "dhcp-host={$mac},{$ip},{$hostname}";
        } else {
            $confLines[] = "dhcp-host={$mac},{$ip}";
        }
    }

    file_put_contents($dhcpConfigFile, implode("\n", $confLines) . "\n");

    if ($deferServiceControl) {
        if (deferServiceAction('rc-service dnsmasq restart || rc-service dnsmasq start', $errors, 'dnsmasq service update')) {
            echo "  DHCP server: enabled on {$interface} (start deferred)\n";
        }
        return;
    }

    $output = [];
    runRcService('dnsmasq', 'restart', $output, $ret);
    if ($ret !== 0) {
        $output = [];
        runRcService('dnsmasq', 'start', $output, $ret);
    }

    if ($ret !== 0) {
        $errors[] = 'Failed to restart or start dnsmasq for DHCP: ' . implode(' ', $output);
        return;
    }

    echo "  DHCP server: enabled on {$interface}\n";
}

function applyNtpService(array $config, array &$errors): void
{
    $ntpConfig = $config['services']['ntp'] ?? [];
    $enabled = (bool)($ntpConfig['enabled'] ?? true);
    $deferServiceControl = (getenv('RC_SVCNAME') === 'coyote-config');

    $servers = normalizeNtpServers($config, $ntpConfig['servers'] ?? ['pool.ntp.org']);
    $serverList = implode(', ', $servers);

    if (!$enabled) {
        if ($deferServiceControl) {
            if (deferServiceAction('rc-service ntpd stop', $errors, 'ntpd service update')) {
                echo "  NTP daemon: disabled (stop deferred)\n";
            }
            return;
        }

        $output = [];
        runRcService('ntpd', 'stop', $output, $ret);
        if ($ret !== 0) {
            $combined = implode(' ', $output);
            if (stripos($combined, 'stopped') === false && stripos($combined, 'not running') === false) {
                $errors[] = 'Failed to stop ntpd while NTP is disabled: ' . $combined;
            }
        }

        echo "  NTP daemon: disabled\n";
        return;
    }

    $requiresResolver = false;
    foreach ($servers as $server) {
        if (filter_var($server, FILTER_VALIDATE_IP) === false) {
            $requiresResolver = true;
            break;
        }
    }

    waitForNetworkAndResolver($requiresResolver);

    $shouldRunOneShot = $deferServiceControl;
    if (!$shouldRunOneShot) {
        exec('pidof lighttpd >/dev/null 2>&1', $lighttpdOutput, $lighttpdRet);
        $shouldRunOneShot = ($lighttpdRet !== 0);
    }

    if ($shouldRunOneShot) {
        $syncOutput = [];
        runNtpOneShot($servers, $syncOutput, $syncRet);
        if ($syncRet === 0) {
            echo "  NTP initial sync: completed ({$serverList})\n";
        } else {
            $syncSummary = implode(' ', array_slice($syncOutput, -2));
            if ($syncSummary !== '') {
                echo "  NTP initial sync: failed ({$serverList}) - {$syncSummary}\n";
            } else {
                echo "  NTP initial sync: failed ({$serverList})\n";
            }
        }
    }

    $ntpdOpts = '-N';
    foreach ($servers as $server) {
        $ntpdOpts .= ' -p ' . escapeshellarg($server);
    }

    $confContent = "# NTP daemon configuration\n";
    $confContent .= "# Generated by Coyote Linux config apply\n\n";
    $confContent .= "NTPD_OPTS=\"{$ntpdOpts}\"\n";

    if (file_put_contents('/etc/conf.d/ntpd', $confContent) === false) {
        $errors[] = 'Failed to write /etc/conf.d/ntpd';
        return;
    }

    if ($deferServiceControl) {
        if (deferServiceAction('rc-service ntpd restart || rc-service ntpd start', $errors, 'ntpd service update')) {
            echo "  NTP daemon: enabled ({$serverList}) (start deferred)\n";
        }
        return;
    }

    $output = [];
    runRcService('ntpd', 'restart', $output, $ret);
    if ($ret !== 0) {
        $output = [];
        runRcService('ntpd', 'start', $output, $ret);
    }

    if ($ret !== 0) {
        $errors[] = 'Failed to restart or start ntpd: ' . implode(' ', $output);
        return;
    }

    echo "  NTP daemon: enabled ({$serverList})\n";
}

function runNtpOneShot(array $servers, array &$output, &$ret): void
{
    $ret = 1;
    $cmd = '/usr/sbin/ntpd -n -q';
    foreach ($servers as $server) {
        $cmd .= ' -p ' . escapeshellarg($server);
    }

    $timeoutBinary = null;
    foreach (['/usr/bin/timeout', '/bin/timeout'] as $candidate) {
        if (is_executable($candidate)) {
            $timeoutBinary = $candidate;
            break;
        }
    }

    if ($timeoutBinary !== null) {
        $cmd = $timeoutBinary . ' 25 ' . $cmd;
    }

    exec($cmd . ' 2>&1', $output, $ret);
}

function normalizeNtpServers(array $config, $serverConfig): array
{
    if (!is_array($serverConfig)) {
        $serverConfig = preg_split('/[\s,]+/', (string)$serverConfig) ?: [];
    }

    $normalizedServers = [];
    foreach ($serverConfig as $server) {
        if (is_array($server)) {
            foreach ($server as $nestedServer) {
                if (is_string($nestedServer)) {
                    $nestedServer = trim($nestedServer);
                    if ($nestedServer !== '') {
                        $normalizedServers[] = $nestedServer;
                    }
                }
            }
            continue;
        }

        if (is_string($server)) {
            $server = trim($server);
            if ($server !== '') {
                $normalizedServers[] = $server;
            }
        }
    }

    if (empty($normalizedServers)) {
        $legacyServer = trim((string)($config['system']['timeserver'] ?? ''));
        if ($legacyServer !== '') {
            $normalizedServers[] = $legacyServer;
        }
    }

    if (empty($normalizedServers)) {
        $normalizedServers[] = 'pool.ntp.org';
    }

    return $normalizedServers;
}

function waitForNetworkAndResolver(bool $requireResolver): void
{
    for ($attempt = 0; $attempt < 12; $attempt++) {
        $routeOutput = [];
        exec('ip route show default 2>/dev/null', $routeOutput, $routeRet);
        $hasDefaultRoute = ($routeRet === 0 && !empty($routeOutput));

        $hasResolver = true;
        if ($requireResolver) {
            $hasResolver = false;
            $resolvLines = @file('/etc/resolv.conf', FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) ?: [];
            foreach ($resolvLines as $line) {
                if (strpos(trim($line), 'nameserver ') === 0) {
                    $hasResolver = true;
                    break;
                }
            }
        }

        if ($hasDefaultRoute && $hasResolver) {
            return;
        }

        sleep(1);
    }
}

/**
 * Get default configuration values.
 */
function getDefaults(): array
{
    $defaultsFile = '/opt/coyote/defaults/system.json';

    if (file_exists($defaultsFile)) {
        $loader = new ConfigLoader();
        return $loader->load($defaultsFile);
    }

    return [
        'system' => [
            'hostname' => 'coyote',
            'timezone' => 'UTC',
        ],
        'network' => [
            'interfaces' => [],
            'routes' => [],
            'dns' => [],
        ],
        'services' => [],
    ];
}

// Main
echo "Applying Coyote Linux configuration...\n";
$success = applyConfig();
exit($success ? 0 : 1);
