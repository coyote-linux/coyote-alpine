<?php

namespace Coyote\LoadBalancer;

use Coyote\Certificate\CertificateStore;
use Coyote\Util\Filesystem;

/**
 * Service for managing HAProxy load balancer.
 *
 * Handles configuration generation, service management, and runtime control.
 */
class HaproxyService
{
    /** @var string Path to HAProxy config file */
    private string $configFile = '/etc/haproxy/haproxy.cfg';

    /** @var string Path to HAProxy socket */
    private string $socketPath = '/var/run/haproxy.sock';

    /** @var string Path to HAProxy binary */
    private string $haproxy = '/usr/sbin/haproxy';

    /**
     * Apply HAProxy configuration.
     *
     * @param array $config Load balancer configuration
     * @return bool True if successful
     */
    public function applyConfig(array $config): bool
    {
        // Generate configuration
        $haproxyConf = $this->generateConfig($config);

        // Validate configuration
        if (!$this->validateConfig($haproxyConf)) {
            return false;
        }

        // Write configuration file
        Filesystem::ensureDir(dirname($this->configFile));
        if (!Filesystem::writeAtomic($this->configFile, $haproxyConf, 0644)) {
            return false;
        }

        // Start or reload service
        if ($this->isRunning()) {
            return $this->reload();
        } else {
            return $this->start();
        }
    }

    /**
     * Generate HAProxy configuration file content.
     *
     * @param array $config Load balancer configuration
     * @return string Configuration content
     */
    public function generateConfig(array $config): string
    {
        $conf = "# Generated by Coyote Linux - do not edit manually\n\n";

        // Global section
        $conf .= $this->generateGlobalSection($config);

        // Defaults section
        $conf .= $this->generateDefaultsSection($config);

        // Stats section if enabled
        if ($config['stats']['enabled'] ?? false) {
            $conf .= $this->generateStatsSection($config['stats']);
        }

        // Frontend sections
        foreach ($config['frontends'] ?? [] as $name => $frontend) {
            $conf .= $this->generateFrontendSection($name, $frontend);
        }

        // Backend sections
        foreach ($config['backends'] ?? [] as $name => $backend) {
            $conf .= $this->generateBackendSection($name, $backend);
        }

        return $conf;
    }

    /**
     * Generate the global section.
     *
     * @param array $config Configuration
     * @return string Global section content
     */
    private function generateGlobalSection(array $config): string
    {
        $conf = "global\n";
        $conf .= "    log /dev/log local0\n";
        $conf .= "    log /dev/log local1 notice\n";
        $conf .= "    chroot /var/lib/haproxy\n";
        $conf .= "    stats socket {$this->socketPath} mode 660 level admin\n";
        $conf .= "    stats timeout 30s\n";
        $conf .= "    user haproxy\n";
        $conf .= "    group haproxy\n";
        $conf .= "    daemon\n";

        // SSL defaults
        $conf .= "    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256\n";
        $conf .= "    ssl-default-bind-options ssl-min-ver TLSv1.2\n";

        $conf .= "\n";

        return $conf;
    }

    /**
     * Generate the defaults section.
     *
     * @param array $config Configuration
     * @return string Defaults section content
     */
    private function generateDefaultsSection(array $config): string
    {
        $defaults = $config['defaults'] ?? [];

        $conf = "defaults\n";
        $conf .= "    log global\n";
        $conf .= "    mode " . ($defaults['mode'] ?? 'http') . "\n";
        $conf .= "    option httplog\n";
        $conf .= "    option dontlognull\n";
        $conf .= "    timeout connect " . ($defaults['timeout_connect'] ?? '5s') . "\n";
        $conf .= "    timeout client " . ($defaults['timeout_client'] ?? '50s') . "\n";
        $conf .= "    timeout server " . ($defaults['timeout_server'] ?? '50s') . "\n";
        $conf .= "    errorfile 400 /etc/haproxy/errors/400.http\n";
        $conf .= "    errorfile 403 /etc/haproxy/errors/403.http\n";
        $conf .= "    errorfile 408 /etc/haproxy/errors/408.http\n";
        $conf .= "    errorfile 500 /etc/haproxy/errors/500.http\n";
        $conf .= "    errorfile 502 /etc/haproxy/errors/502.http\n";
        $conf .= "    errorfile 503 /etc/haproxy/errors/503.http\n";
        $conf .= "    errorfile 504 /etc/haproxy/errors/504.http\n";
        $conf .= "\n";

        return $conf;
    }

    /**
     * Generate the stats section.
     *
     * @param array $stats Stats configuration
     * @return string Stats section content
     */
    private function generateStatsSection(array $stats): string
    {
        $port = $stats['port'] ?? 8404;
        $uri = $stats['uri'] ?? '/stats';

        $conf = "frontend stats\n";
        $conf .= "    bind *:{$port}\n";
        $conf .= "    mode http\n";
        $conf .= "    stats enable\n";
        $conf .= "    stats uri {$uri}\n";
        $conf .= "    stats refresh 10s\n";

        if (isset($stats['auth'])) {
            $conf .= "    stats auth {$stats['auth']}\n";
        }

        $conf .= "\n";

        return $conf;
    }

    /**
     * Generate a frontend section.
     *
     * @param string $name Frontend name
     * @param array $frontend Frontend configuration
     * @return string Frontend section content
     */
    private function generateFrontendSection(string $name, array $frontend): string
    {
        $conf = "frontend {$name}\n";
        $conf .= "    bind {$frontend['bind']}\n";

        if (isset($frontend['mode'])) {
            $conf .= "    mode {$frontend['mode']}\n";
        }

        // SSL certificate
        if (isset($frontend['ssl_cert'])) {
            $sslCertPath = $this->resolveSslCertificatePath((string)$frontend['ssl_cert']);
            if ($sslCertPath !== '') {
                $conf .= "    bind *:443 ssl crt {$sslCertPath}\n";
            }
        }

        // HTTP options
        if (($frontend['mode'] ?? 'http') === 'http') {
            $conf .= "    option forwardfor\n";
            if ($frontend['http_request_add_header'] ?? false) {
                $conf .= "    http-request add-header X-Forwarded-Proto https if { ssl_fc }\n";
            }
        }

        // ACLs
        foreach ($frontend['acls'] ?? [] as $aclName => $acl) {
            $conf .= "    acl {$aclName} {$acl}\n";
        }

        // Use backend rules
        foreach ($frontend['use_backend'] ?? [] as $rule) {
            if (isset($rule['condition'])) {
                $conf .= "    use_backend {$rule['backend']} if {$rule['condition']}\n";
            }
        }

        // Default backend
        if (isset($frontend['backend'])) {
            $conf .= "    default_backend {$frontend['backend']}\n";
        }

        $conf .= "\n";

        return $conf;
    }

    /**
     * Generate a backend section.
     *
     * @param string $name Backend name
     * @param array $backend Backend configuration
     * @return string Backend section content
     */
    private function generateBackendSection(string $name, array $backend): string
    {
        $conf = "backend {$name}\n";

        if (isset($backend['mode'])) {
            $conf .= "    mode {$backend['mode']}\n";
        }

        $conf .= "    balance " . ($backend['balance'] ?? 'roundrobin') . "\n";

        // Health check
        if ($backend['health_check'] ?? true) {
            $conf .= "    option httpchk " . ($backend['health_check_path'] ?? 'GET /') . "\n";
        }

        // Cookie for session persistence
        if (isset($backend['cookie'])) {
            $conf .= "    cookie {$backend['cookie']} insert indirect nocache\n";
        }

        // Servers
        foreach ($backend['servers'] ?? [] as $server) {
            $serverName = $server['name'] ?? preg_replace('/[^a-zA-Z0-9]/', '_', $server['address']);
            $address = $server['address'];
            $port = $server['port'] ?? 80;
            $weight = $server['weight'] ?? 1;

            $conf .= "    server {$serverName} {$address}:{$port} weight {$weight} check";

            if (isset($backend['cookie'])) {
                $conf .= " cookie {$serverName}";
            }

            if ($server['backup'] ?? false) {
                $conf .= " backup";
            }

            $conf .= "\n";
        }

        $conf .= "\n";

        return $conf;
    }

    private function resolveSslCertificatePath(string $sslCert): string
    {
        $sslCert = trim($sslCert);
        if ($sslCert === '') {
            return '';
        }

        if (str_starts_with($sslCert, '/')) {
            return $sslCert;
        }

        if (!str_starts_with($sslCert, 'cert_')) {
            return '';
        }

        $store = new CertificateStore();
        if (!$store->initialize()) {
            return '';
        }

        return (string)($store->getPath($sslCert) ?? '');
    }

    /**
     * Validate a configuration before applying.
     *
     * @param string $config Configuration content
     * @return bool True if valid
     */
    public function validateConfig(string $config): bool
    {
        // Write to temp file
        $tempFile = Filesystem::tempFile('haproxy');
        if ($tempFile === null) {
            return false;
        }

        file_put_contents($tempFile, $config);

        // Validate using haproxy -c
        exec("{$this->haproxy} -c -f {$tempFile} 2>&1", $output, $returnCode);

        unlink($tempFile);

        return $returnCode === 0;
    }

    /**
     * Start HAProxy service.
     *
     * @return bool True if successful
     */
    public function start(): bool
    {
        exec('rc-service haproxy start 2>&1', $output, $returnCode);
        return $returnCode === 0;
    }

    /**
     * Stop HAProxy service.
     *
     * @return bool True if successful
     */
    public function stop(): bool
    {
        exec('rc-service haproxy stop 2>&1', $output, $returnCode);
        return $returnCode === 0;
    }

    /**
     * Reload HAProxy configuration (graceful).
     *
     * @return bool True if successful
     */
    public function reload(): bool
    {
        exec('rc-service haproxy reload 2>&1', $output, $returnCode);
        return $returnCode === 0;
    }

    /**
     * Check if HAProxy is running.
     *
     * @return bool True if running
     */
    public function isRunning(): bool
    {
        exec('rc-service haproxy status 2>&1', $output, $returnCode);
        return $returnCode === 0;
    }

    /**
     * Send a command to HAProxy runtime API via socket.
     *
     * @param string $command Command to send
     * @return string|null Response or null on failure
     */
    public function sendCommand(string $command): ?string
    {
        if (!file_exists($this->socketPath)) {
            return null;
        }

        $socket = @fsockopen("unix://{$this->socketPath}", 0, $errno, $errstr, 5);
        if (!$socket) {
            return null;
        }

        fwrite($socket, $command . "\n");

        $response = '';
        while (!feof($socket)) {
            $response .= fgets($socket, 1024);
        }

        fclose($socket);

        return $response;
    }

    /**
     * Enable a server in a backend.
     *
     * @param string $backend Backend name
     * @param string $server Server name
     * @return bool True if successful
     */
    public function enableServer(string $backend, string $server): bool
    {
        $response = $this->sendCommand("enable server {$backend}/{$server}");
        return $response !== null;
    }

    /**
     * Disable a server in a backend.
     *
     * @param string $backend Backend name
     * @param string $server Server name
     * @return bool True if successful
     */
    public function disableServer(string $backend, string $server): bool
    {
        $response = $this->sendCommand("disable server {$backend}/{$server}");
        return $response !== null;
    }

    /**
     * Set server weight.
     *
     * @param string $backend Backend name
     * @param string $server Server name
     * @param int $weight New weight
     * @return bool True if successful
     */
    public function setServerWeight(string $backend, string $server, int $weight): bool
    {
        $response = $this->sendCommand("set server {$backend}/{$server} weight {$weight}");
        return $response !== null;
    }
}
