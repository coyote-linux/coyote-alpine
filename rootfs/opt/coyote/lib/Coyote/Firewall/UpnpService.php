<?php

namespace Coyote\Firewall;

use Coyote\Util\Logger;

/**
 * UPnP/IGD service manager for miniupnpd.
 *
 * Handles configuration generation for miniupnpd with nftables backend,
 * service management, and integration with the Coyote firewall.
 */
class UpnpService
{
    /** @var InterfaceResolver */
    private InterfaceResolver $resolver;

    /** @var Logger */
    private Logger $logger;

    /** @var bool Whether UPnP is enabled */
    private bool $enabled = false;

    /** @var string Internal (LAN) interface */
    private string $internalInterface = 'lan';

    /** @var string External (WAN) interface */
    private string $externalInterface = 'wan';

    /** @var int HTTP SOAP port */
    private int $port = 5000;

    /** @var bool Secure mode - clients can only forward to themselves */
    private bool $secureMode = true;

    /** @var bool Enable UPnP IGD protocol */
    private bool $upnpEnabled = true;

    /** @var bool Enable NAT-PMP protocol */
    private bool $natPmpEnabled = false;

    /** @var bool Enable PCP protocol */
    private bool $pcpEnabled = false;

    /** @var string UUID for the device */
    private string $uuid = '';

    /** @var string Friendly device name */
    private string $friendlyName = 'Coyote Linux Router';

    /** @var string Manufacturer name */
    private string $manufacturer = 'Coyote Linux';

    /** @var string Model name */
    private string $modelName = 'Coyote 4 Firewall';

    /** @var int Default lease duration in seconds */
    private int $leaseDuration = 86400;

    /** @var int Clean rules interval in seconds */
    private int $cleanRulesInterval = 600;

    /** @var array Allowed port ranges */
    private array $allowRules = [];

    /** @var array Denied port ranges */
    private array $denyRules = [];

    /** @var string Configuration file path */
    private string $configPath = '/etc/miniupnpd/miniupnpd.conf';

    /** @var string Lease file path */
    private string $leasePath = '/var/lib/miniupnpd/leases';

    /** @var array nftables chain names */
    private const NFT_CHAINS = [
        'filter_table' => 'inet filter',
        'nat_table' => 'inet nat',
        'forward_chain' => 'igd-forward',
        'preroute_chain' => 'igd-preroute',
        'postroute_chain' => 'postrouting',
    ];

    /**
     * Create a new UpnpService instance.
     *
     * @param InterfaceResolver|null $resolver Optional resolver instance
     */
    public function __construct(?InterfaceResolver $resolver = null)
    {
        $this->resolver = $resolver ?? new InterfaceResolver();
        $this->logger = new Logger('upnp-service');

        // Generate stable UUID based on hostname
        $this->uuid = $this->generateUuid();
    }

    /**
     * Load UPnP configuration.
     *
     * @param array $config UPnP service configuration
     * @param array $networkConfig Network configuration for interface resolution
     * @return self
     */
    public function loadConfig(array $config, array $networkConfig = []): self
    {
        if (!empty($networkConfig)) {
            $this->resolver->loadConfig($networkConfig);
        }

        $this->enabled = $config['enabled'] ?? false;
        $this->internalInterface = $config['interface'] ?? 'lan';
        $this->externalInterface = $config['external_interface'] ?? 'wan';
        $this->port = $config['port'] ?? 5000;
        $this->secureMode = $config['secure_mode'] ?? true;
        $this->upnpEnabled = $config['upnp'] ?? true;
        $this->natPmpEnabled = $config['nat_pmp'] ?? false;
        $this->pcpEnabled = $config['pcp'] ?? false;
        $this->friendlyName = $config['friendly_name'] ?? 'Coyote Linux Router';
        $this->leaseDuration = $config['lease_duration'] ?? 86400;
        $this->cleanRulesInterval = $config['clean_interval'] ?? 600;

        // UUID from config or generate
        if (!empty($config['uuid'])) {
            $this->uuid = $config['uuid'];
        }

        // Port rules
        $this->allowRules = $config['allow'] ?? [];
        $this->denyRules = $config['deny'] ?? [];

        return $this;
    }

    /**
     * Generate miniupnpd configuration file content.
     *
     * @return string Configuration file content
     */
    public function generateConfig(): string
    {
        if (!$this->enabled) {
            return "# UPnP disabled\n";
        }

        $lines = [];
        $lines[] = '# miniupnpd configuration - generated by Coyote Linux';
        $lines[] = '# Do not edit manually - changes will be overwritten';
        $lines[] = '';

        // External interface (WAN)
        $extInterfaces = $this->resolver->resolve($this->externalInterface);
        $extIface = $extInterfaces[0] ?? 'eth0';
        $lines[] = "ext_ifname={$extIface}";
        $lines[] = '';

        // Internal/listening interface (LAN)
        $intInterfaces = $this->resolver->resolve($this->internalInterface);
        foreach ($intInterfaces as $iface) {
            $lines[] = "listening_ip={$iface}";
        }
        $lines[] = '';

        // Port
        $lines[] = "port={$this->port}";
        $lines[] = '';

        // Protocol enables
        $lines[] = 'enable_upnp=' . ($this->upnpEnabled ? 'yes' : 'no');
        $lines[] = 'enable_natpmp=' . ($this->natPmpEnabled ? 'yes' : 'no');
        $lines[] = 'enable_pcp=' . ($this->pcpEnabled ? 'yes' : 'no');
        $lines[] = '';

        // Security settings
        $lines[] = 'secure_mode=' . ($this->secureMode ? 'yes' : 'no');
        $lines[] = '';

        // nftables configuration
        $lines[] = '# nftables backend';
        $lines[] = 'upnp_table_name=' . self::NFT_CHAINS['filter_table'];
        $lines[] = 'upnp_nat_table_name=' . self::NFT_CHAINS['nat_table'];
        $lines[] = 'upnp_forward_chain=' . self::NFT_CHAINS['forward_chain'];
        $lines[] = 'upnp_nat_chain=' . self::NFT_CHAINS['preroute_chain'];
        $lines[] = 'upnp_nat_postrouting_chain=' . self::NFT_CHAINS['postroute_chain'];
        $lines[] = '';

        // Device identity
        $lines[] = '# Device identity';
        $lines[] = "uuid={$this->uuid}";
        $lines[] = "friendly_name={$this->friendlyName}";
        $lines[] = "manufacturer_name={$this->manufacturer}";
        $lines[] = "model_name={$this->modelName}";
        $lines[] = 'model_number=4.0';
        $lines[] = '';

        // Timing settings
        $lines[] = '# Timing';
        $lines[] = "clean_ruleset_interval={$this->cleanRulesInterval}";
        $lines[] = "lease_file={$this->leasePath}";
        $lines[] = '';

        // System settings
        $lines[] = '# System';
        $lines[] = 'system_uptime=yes';
        $lines[] = 'notify_interval=60';
        $lines[] = '';

        // Bitrates (0 = auto-detect)
        $lines[] = '# Bitrates (0 = auto-detect)';
        $lines[] = 'bitrate_up=0';
        $lines[] = 'bitrate_down=0';
        $lines[] = '';

        // Permission rules
        $lines[] = '# Permission rules (allow|deny ext_port[-ext_port] int_ip/mask int_port[-int_port])';
        $lines[] = '# Order matters - first match wins';
        $lines[] = '';

        // Default rules if none specified
        if (empty($this->allowRules) && empty($this->denyRules)) {
            $lines[] = '# Default: allow common ports from LAN';
            $lines[] = 'allow 1024-65535 0.0.0.0/0 1024-65535';
            $lines[] = 'deny 0-65535 0.0.0.0/0 0-65535';
        } else {
            // User-defined rules
            foreach ($this->allowRules as $rule) {
                $lines[] = $this->formatPermRule('allow', $rule);
            }
            foreach ($this->denyRules as $rule) {
                $lines[] = $this->formatPermRule('deny', $rule);
            }
            // Final deny
            $lines[] = 'deny 0-65535 0.0.0.0/0 0-65535';
        }

        $lines[] = '';
        return implode("\n", $lines);
    }

    /**
     * Format a permission rule.
     *
     * @param string $action allow or deny
     * @param array $rule Rule configuration
     * @return string Formatted rule
     */
    private function formatPermRule(string $action, array $rule): string
    {
        $extPort = $rule['external_port'] ?? '1024-65535';
        $intIp = $rule['internal_ip'] ?? '0.0.0.0/0';
        $intPort = $rule['internal_port'] ?? '1024-65535';

        return "{$action} {$extPort} {$intIp} {$intPort}";
    }

    /**
     * Write the configuration file.
     *
     * @return bool True if successful
     */
    public function writeConfig(): bool
    {
        $config = $this->generateConfig();
        $dir = dirname($this->configPath);

        if (!is_dir($dir)) {
            if (!mkdir($dir, 0755, true)) {
                $this->logger->error("Failed to create config directory: {$dir}");
                return false;
            }
        }

        if (file_put_contents($this->configPath, $config) === false) {
            $this->logger->error("Failed to write config: {$this->configPath}");
            return false;
        }

        $this->logger->info("UPnP configuration written to {$this->configPath}");
        return true;
    }

    /**
     * Ensure lease directory exists.
     *
     * @return bool True if successful
     */
    public function ensureLeaseDir(): bool
    {
        $dir = dirname($this->leasePath);

        if (!is_dir($dir)) {
            if (!mkdir($dir, 0755, true)) {
                $this->logger->error("Failed to create lease directory: {$dir}");
                return false;
            }
        }

        return true;
    }

    /**
     * Generate a stable UUID based on system identity.
     *
     * @return string UUID string
     */
    private function generateUuid(): string
    {
        // Try to get machine-id
        $machineId = '';
        if (file_exists('/etc/machine-id')) {
            $machineId = trim(file_get_contents('/etc/machine-id'));
        } elseif (file_exists('/var/lib/dbus/machine-id')) {
            $machineId = trim(file_get_contents('/var/lib/dbus/machine-id'));
        }

        if (empty($machineId)) {
            // Fallback to hostname
            $machineId = gethostname() ?: 'coyote';
        }

        // Create UUID v5 (name-based) using DNS namespace
        $namespace = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
        $hash = sha1(hex2bin(str_replace('-', '', $namespace)) . $machineId);

        return sprintf(
            '%08s-%04s-5%03s-%04x-%012s',
            substr($hash, 0, 8),
            substr($hash, 8, 4),
            substr($hash, 13, 3),
            (hexdec(substr($hash, 16, 4)) & 0x3fff) | 0x8000,
            substr($hash, 20, 12)
        );
    }

    /**
     * Get active UPnP leases.
     *
     * @return array Array of lease information
     */
    public function getLeases(): array
    {
        if (!file_exists($this->leasePath)) {
            return [];
        }

        $leases = [];
        $lines = file($this->leasePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

        foreach ($lines as $line) {
            if (strpos($line, '#') === 0) {
                continue;
            }

            // Format: protocol:ext_port:int_client:int_port:timestamp:description
            $parts = explode(':', $line);
            if (count($parts) >= 5) {
                $leases[] = [
                    'protocol' => $parts[0],
                    'external_port' => (int)$parts[1],
                    'internal_ip' => $parts[2],
                    'internal_port' => (int)$parts[3],
                    'expires' => (int)$parts[4],
                    'description' => $parts[5] ?? '',
                    'remaining' => max(0, (int)$parts[4] - time()),
                ];
            }
        }

        return $leases;
    }

    /**
     * Get lease count.
     *
     * @return int Number of active leases
     */
    public function getLeaseCount(): int
    {
        return count($this->getLeases());
    }

    /**
     * Check if miniupnpd service is running.
     *
     * @return bool True if running
     */
    public function isRunning(): bool
    {
        exec('pidof miniupnpd 2>/dev/null', $output, $exitCode);
        return $exitCode === 0;
    }

    /**
     * Start the UPnP service.
     *
     * @return bool True if successful
     */
    public function start(): bool
    {
        if (!$this->enabled) {
            $this->logger->warning('Cannot start UPnP - service is disabled');
            return false;
        }

        // Ensure directories exist
        $this->ensureLeaseDir();

        // Write configuration
        if (!$this->writeConfig()) {
            return false;
        }

        // Start service
        exec('rc-service miniupnpd start 2>&1', $output, $exitCode);

        if ($exitCode !== 0) {
            $this->logger->error('Failed to start miniupnpd: ' . implode("\n", $output));
            return false;
        }

        $this->logger->info('miniupnpd started successfully');
        return true;
    }

    /**
     * Stop the UPnP service.
     *
     * @return bool True if successful
     */
    public function stop(): bool
    {
        exec('rc-service miniupnpd stop 2>&1', $output, $exitCode);

        if ($exitCode !== 0) {
            $this->logger->warning('Failed to stop miniupnpd gracefully');
            // Try harder
            exec('pkill miniupnpd 2>/dev/null');
        }

        $this->logger->info('miniupnpd stopped');
        return true;
    }

    /**
     * Restart the UPnP service.
     *
     * @return bool True if successful
     */
    public function restart(): bool
    {
        $this->stop();
        return $this->start();
    }

    /**
     * Reload configuration without full restart.
     *
     * @return bool True if successful
     */
    public function reload(): bool
    {
        if (!$this->isRunning()) {
            return $this->start();
        }

        // Write new config
        if (!$this->writeConfig()) {
            return false;
        }

        // Send SIGHUP to reload
        exec('pkill -HUP miniupnpd 2>&1', $output, $exitCode);

        if ($exitCode !== 0) {
            $this->logger->warning('Failed to reload, performing restart');
            return $this->restart();
        }

        $this->logger->info('miniupnpd configuration reloaded');
        return true;
    }

    /**
     * Apply UPnP configuration.
     *
     * This is the main entry point called by the subsystem manager.
     *
     * @return bool True if successful
     */
    public function apply(): bool
    {
        if (!$this->enabled) {
            if ($this->isRunning()) {
                return $this->stop();
            }
            return true;
        }

        return $this->restart();
    }

    /**
     * Get service status information.
     *
     * @return array Status array
     */
    public function getStatus(): array
    {
        return [
            'enabled' => $this->enabled,
            'running' => $this->isRunning(),
            'internal_interface' => $this->internalInterface,
            'external_interface' => $this->externalInterface,
            'port' => $this->port,
            'secure_mode' => $this->secureMode,
            'protocols' => [
                'upnp' => $this->upnpEnabled,
                'nat_pmp' => $this->natPmpEnabled,
                'pcp' => $this->pcpEnabled,
            ],
            'lease_count' => $this->getLeaseCount(),
            'leases' => $this->getLeases(),
        ];
    }

    /**
     * Check if UPnP is enabled.
     *
     * @return bool
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }

    /**
     * Enable or disable UPnP.
     *
     * @param bool $enabled
     * @return self
     */
    public function setEnabled(bool $enabled): self
    {
        $this->enabled = $enabled;
        return $this;
    }

    /**
     * Set internal (LAN) interface.
     *
     * @param string $interface Interface name or role
     * @return self
     */
    public function setInternalInterface(string $interface): self
    {
        $this->internalInterface = $interface;
        return $this;
    }

    /**
     * Set external (WAN) interface.
     *
     * @param string $interface Interface name or role
     * @return self
     */
    public function setExternalInterface(string $interface): self
    {
        $this->externalInterface = $interface;
        return $this;
    }

    /**
     * Set secure mode.
     *
     * @param bool $secure
     * @return self
     */
    public function setSecureMode(bool $secure): self
    {
        $this->secureMode = $secure;
        return $this;
    }

    /**
     * Enable NAT-PMP protocol.
     *
     * @param bool $enabled
     * @return self
     */
    public function setNatPmpEnabled(bool $enabled): self
    {
        $this->natPmpEnabled = $enabled;
        return $this;
    }

    /**
     * Enable PCP protocol.
     *
     * @param bool $enabled
     * @return self
     */
    public function setPcpEnabled(bool $enabled): self
    {
        $this->pcpEnabled = $enabled;
        return $this;
    }

    /**
     * Add an allow rule.
     *
     * @param string $extPort External port or range (e.g., "1024-65535")
     * @param string $intIp Internal IP/mask (e.g., "192.168.1.0/24")
     * @param string $intPort Internal port or range
     * @return self
     */
    public function addAllowRule(string $extPort, string $intIp = '0.0.0.0/0', string $intPort = '1024-65535'): self
    {
        $this->allowRules[] = [
            'external_port' => $extPort,
            'internal_ip' => $intIp,
            'internal_port' => $intPort,
        ];
        return $this;
    }

    /**
     * Add a deny rule.
     *
     * @param string $extPort External port or range
     * @param string $intIp Internal IP/mask
     * @param string $intPort Internal port or range
     * @return self
     */
    public function addDenyRule(string $extPort, string $intIp = '0.0.0.0/0', string $intPort = '0-65535'): self
    {
        $this->denyRules[] = [
            'external_port' => $extPort,
            'internal_ip' => $intIp,
            'internal_port' => $intPort,
        ];
        return $this;
    }

    /**
     * Get configuration file path.
     *
     * @return string
     */
    public function getConfigPath(): string
    {
        return $this->configPath;
    }

    /**
     * Set configuration file path.
     *
     * @param string $path
     * @return self
     */
    public function setConfigPath(string $path): self
    {
        $this->configPath = $path;
        return $this;
    }

    /**
     * Get the current configuration as an array.
     *
     * @return array Configuration array
     */
    public function getConfig(): array
    {
        return [
            'enabled' => $this->enabled,
            'interface' => $this->internalInterface,
            'external_interface' => $this->externalInterface,
            'port' => $this->port,
            'secure_mode' => $this->secureMode,
            'upnp' => $this->upnpEnabled,
            'nat_pmp' => $this->natPmpEnabled,
            'pcp' => $this->pcpEnabled,
            'uuid' => $this->uuid,
            'friendly_name' => $this->friendlyName,
            'lease_duration' => $this->leaseDuration,
            'clean_interval' => $this->cleanRulesInterval,
            'allow' => $this->allowRules,
            'deny' => $this->denyRules,
        ];
    }

    /**
     * Get a preset UPnP configuration.
     *
     * @param string $preset Preset name (disabled, basic, full)
     * @return array UPnP configuration
     */
    public static function getPreset(string $preset): array
    {
        switch ($preset) {
            case 'disabled':
                return [
                    'enabled' => false,
                ];

            case 'basic':
                return [
                    'enabled' => true,
                    'interface' => 'lan',
                    'external_interface' => 'wan',
                    'port' => 5000,
                    'secure_mode' => true,
                    'upnp' => true,
                    'nat_pmp' => false,
                    'pcp' => false,
                ];

            case 'full':
                return [
                    'enabled' => true,
                    'interface' => 'lan',
                    'external_interface' => 'wan',
                    'port' => 5000,
                    'secure_mode' => true,
                    'upnp' => true,
                    'nat_pmp' => true,
                    'pcp' => true,
                ];

            default:
                return self::getPreset('basic');
        }
    }

    /**
     * Get available preset names.
     *
     * @return array Preset names with descriptions
     */
    public static function getAvailablePresets(): array
    {
        return [
            'disabled' => 'UPnP disabled - no automatic port forwarding',
            'basic' => 'Basic UPnP - IGD protocol only, secure mode enabled',
            'full' => 'Full UPnP - IGD, NAT-PMP, and PCP protocols enabled',
        ];
    }
}
